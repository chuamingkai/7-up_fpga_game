module stopwatch (
 input clk, // clock
 input rst, // reset
The Finite-State Machine | 87
 input start_stop, // start/stop signal
 output value[14] // counter value
 ) {

 .clk(clk){
 .rst(rst){
 fsm state = {IDLE, RUNNING, PAUSED};
 }
 dff tenth_ctr[23]; // need to store up to 4,999,999
 dff ctr[14]; // need to store up to 9999
 }

 always {
 value = ctr.q; // output counter

 case (state.q) { // FSM case statement
 state.IDLE: // IDLE: not counting
 tenth_ctr.d = 0; // reset tenths counter
 ctr.d = 0; // reset main counter
 if (start_stop) // if start_stop pressed
 state.d = state.RUNNING; // switch to RUNNING state

 state.RUNNING: // RUNNING: increment counters
 tenth_ctr.d = tenth_ctr.q + 1; // increment tenths counter

 if (tenth_ctr.q == 4999999) { // if max value
 tenth_ctr.d = 0; // reset to 0
 ctr.d = ctr.q + 1; // increment main counter
 if (ctr.q == 9999) // if max value
 ctr.d = 0; // reset to 0
 }

 if (start_stop) // if start_stop pressed
 state.d = state.PAUSED; // switch to PAUSED state

 state.PAUSED: // PAUSED: maintain count but do nothing
 if (start_stop) // if start_stop pressed
 state.d = state.RUNNING; // switch back to RUNNING
 }
 }
}




//The below is for the top, maybe we can re-use this logic by having the opponent button start the counter and the current player's button reset the 'stopwatch'



//.clk(clk) {
 // The reset conditioner is used to synchronize the reset signal to the FPGA
 // clock. This ensures the entire FPGA comes out of reset at the same time.
 //reset_conditioner reset_cond;

 //button_conditioner start_stop_button;
 //button_conditioner reset_button;
 //stopwatch stopwatch;

 //edge_detector start_stop_edge (#RISE(1), #FALL(0));

 //.rst(rst) {
 //multi_seven_seg seg_display;
//The Stopwatch | 89
 //}
 //}
//Notice that we didnâ€™t put the stopwatch instance in the reset port connection block.
//This is because we are going to manually connect this later in the always block:
 //start_stop_button.in = io_button[1]; // center button
 //reset_button.in = io_button[3]; // left button

 // connect button to edge detector
 //start_stop_edge.in = start_stop_button.out;

 //stopwatch.start_stop = start_stop_edge.out; // rising edge of start/stop
 //stopwatch.rst = rst | reset_button.out; // reset on rst or reset_button

 //digits.value = stopwatch.value; // display stopwatch value
 //seg_display.values = digits.digits; // digit values to display
 //seg_display.decimal = 4b0010; // turn on second decimal point

 //io_seg = ~seg_display.seg;
 //io_sel = ~seg_display.sel;
